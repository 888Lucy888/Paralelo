#include <cuda.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

// Define macro for handling GPU errors
#define GPUErrorAssertion(ans) { gpuAssert((ans), __FILE__, __LINE__); }

// Inline function to handle GPU errors
inline void gpuAssert(cudaError_t code, const char* file, int line, bool abort = true) {
    if (code != cudaSuccess) {
        fprintf(stderr, "GPUassert: %s %s %d\n\n", cudaGetErrorString(code), file, line);
        if (abort) exit(code);
    }
}

// Function: fillSudokuSafeAndFork
// Description: Kernel function to fill Sudoku safely and fork if necessary.
// Parameters:
// - memory: Pointer to the memory containing the Sudoku boards.
// - stats: Pointer to the array containing the status of each Sudoku board.
__global__ void fillSudokuSafeAndFork(char* memory, int* stats) {
    /*
        We have nBlocks many available blocks.
    */
    uint i, current_poss, j, temp, mat_i, mat_j, k;
    char* block_memory = memory + (81 * blockIdx.x);

    __shared__ uint row_used_numbers[9];
    __shared__ uint col_used_numbers[9];
    __shared__ uint cell_used_numbers[9];
    __shared__ char progress_flag;
    __shared__ char done_flag;
    __shared__ char error_flag;
    __shared__ int min_forks;
    __shared__ int scheduling_thread;

    // Check whether all blocks are idle or not. This shouldn't happen
    if (blockIdx.x == 0) { //first block
        if (threadIdx.x == 0) {
            progress_flag = 0;
        }
        __syncthreads();
        for (i = threadIdx.x; i < gridDim.x; i += blockDim.x) {
            if (stats[i] > 0) {
                progress_flag = 1;
            }
        }
        __syncthreads();
        if (progress_flag == 0 && threadIdx.x == 0) {
            // No active block, terminate.
            printf("No active blocks...terminating\n");
            stats[gridDim.x] = 2;
        }
    }

    // If block is active, work on it
    if (stats[blockIdx.x] == 1) {
        if (threadIdx.x == 0) {
            error_flag = 0;  // Set to 1 if the board is wrong
            done_flag = 0;   // Set to 1 if the board is solved
            progress_flag = 1; // Set to 0 if no deterministic progress can be made
        }
        __syncthreads();

        while (!error_flag && !done_flag && progress_flag) {
            __syncthreads();
            // 1st check whether the board is valid and fill X_used_numbers arrays for rows, columns, and cells.
            //*************************
            if (threadIdx.x < 9) {
                row_used_numbers[threadIdx.x] = 0;
                col_used_numbers[threadIdx.x] = 0;
                cell_used_numbers[threadIdx.x] = 0;
                for (i = 0; i < 9; i++) {
                    // Rows
                    temp = block_memory[threadIdx.x * 9 + i];
                    if (temp) {
                        if ((row_used_numbers[threadIdx.x] >> (temp - 1)) & 1) {
                            // This is bad, you have the same number in the same row. This solution fails
                            error_flag = 10 + i;
                        }
                        // Set nth bit to 1
                        row_used_numbers[threadIdx.x] |= 1 << (temp - 1);
                    }
                    // Columns
                    temp = block_memory[i * 9 + threadIdx.x];
                    if (temp) {
                        if ((col_used_numbers[threadIdx.x] >> (temp - 1)) & 1) {
                            // This is bad, you have the same number in the same column. This solution fails
                            error_flag = 20 + i;
                        }
                        // Set nth bit to 1
                        col_used_numbers[threadIdx.x] |= 1 << (temp - 1);
                    }
                }
                // Cells
                for (i = (threadIdx.x / 3) * 3; i < ((threadIdx.x / 3 + 1) * 3); i++) {
                    for (j = (threadIdx.x % 3) * 3; j < ((threadIdx.x % 3 + 1) * 3); j++) {
                        temp = block_memory[i * 9 + j];
                        if (temp) {
                            if ((cell_used_numbers[threadIdx.x] >> (temp - 1)) & 1) {
                                // This is bad, you have the same number in the same cell. This solution fails
                                error_flag = 30 + i;
                            }
                            // Set nth bit to 1
                            cell_used_numbers[threadIdx.x] |= 1 << (temp - 1);
                        }
                    }
                }
            }
            __syncthreads();
            if (error_flag == 0) {
                if (threadIdx.x == 0) {
                    progress_flag = 0;
                    done_flag = 1;
                }
                __syncthreads();
                if (threadIdx.x < 81) {
                    // 2nd for each cell, calculate available numbers (row_used OR col_used OR cell_used)
                    if (block_memory[threadIdx.x] == 0) {
                        mat_i = threadIdx.x / 9;
                        mat_j = threadIdx.x % 9;
                        current_poss = ~(row_used_numbers[mat_i] | col_used_numbers[mat_j] |
                                         cell_used_numbers[(mat_i / 3) * 3 + (mat_j / 3)]);
                        if (current_poss == 0) {
                            error_flag = 40 + threadIdx.x;
                        } else if ((current_poss & (current_poss - 1)) == 0) {
                            // Unique solution
                            block_memory[threadIdx.x] = (char) __ffs(current_poss);
                        } else {
                            // Multiple solutions
                            if (threadIdx.x == 0) {
                                progress_flag = 1;
                            }
                        }
                    }
                }
            }
            __syncthreads();
        }
        __syncthreads();
    }
    if (threadIdx.x == 0) {
        if (error_flag) {
            // Error detected, report it
            printf("Error detected on block %d in phase %d!\n", blockIdx.x, error_flag);
            stats[blockIdx.x] = 0;
        } else if (done_flag) {
            // Solution found, report it
            printf("Block %d has completed successfully!\n", blockIdx.x);
            stats[blockIdx.x] = 2;
        } else {
            // Block is still active, keep it running
            stats[blockIdx.x] = 1;
        }
    }
}

// Function: device_validity_all
// Description: Kernel function to check the validity of all Sudoku boards.
// Parameters:
// - sudoku_memory: Pointer to the memory containing the Sudoku boards.
// - stats: Pointer to the array containing the status of each Sudoku board.
__global__ void device_validity_all(char* sudoku_memory, int* stats) {
    uint i, j;
    __shared__ char validity;
    __shared__ char error_flag;
    if (threadIdx.x == 0) {
        error_flag = 0;
    }
    __syncthreads();
    for (i = blockIdx.x * blockDim.x + threadIdx.x; i < gridDim.x * 81; i += blockDim.x * gridDim.x) {
        if (i % 81 == 0) {
            validity = 0; // Reset for each new block
        }
        // Skip empty blocks
        if (stats[i / 81] > 0) {
            // Validate the current cell
            for (j = 0; j < 9; j++) {
                // Validate the row
                char val = sudoku_memory[(i / 81) * 9 * 9 + j * 9 + (i % 81) % 9];
                if (val != 0 && (validity & (1 << val))) {
                    error_flag = 1;
                } else {
                    validity |= 1 << val;
                }
                // Validate the column
                val = sudoku_memory[(i / 81) * 9 * 9 + (i % 81) / 9 + j * 9];
                if (val != 0 && (validity & (1 << val))) {
                    error_flag = 1;
                } else {
                    validity |= 1 << val;
                }
                // Validate the subsquare
                val = sudoku_memory[(i / 81) * 9 * 9 + ((i % 81) / 9 / 3) * 27 + (j / 3) * 9 + ((i % 81) % 9 / 3) * 3 + j % 3];
                if (val != 0 && (validity & (1 << val))) {
                    error_flag = 1;
                } else {
                    validity |= 1 << val;
                }
            }
        }
        __syncthreads();
    }
    if (error_flag && threadIdx.x == 0) {
        printf("Error detected in kernel device_validity_all on block %d!\n", blockIdx.x);
        stats[gridDim.x] = 0;
    }
}

// Function: solveSudokuGPU
// Description: Host function to solve Sudoku using GPU.
// Parameters:
// - sudoku_memory: Pointer to the memory containing the Sudoku boards.
// - stats: Pointer to the array containing the status of each Sudoku board.
// - max_forks: Maximum number of blocks (or Sudoku boards) to solve.
void solveSudokuGPU(char* sudoku_memory, int* stats, int max_forks) {
    char* cuda_memory;
    int* cuda_stats;
    cudaMalloc(&cuda_memory, 81 * max_forks);
    GPUErrorAssertion(cudaMalloc(&cuda_stats, (max_forks + 1) * sizeof(int)));
    char* memory = (char*) malloc(81 * max_forks);
    GPUErrorAssertion(cudaMemcpy(cuda_memory, sudoku_memory, 81 * max_forks, cudaMemcpyHostToDevice));
    GPUErrorAssertion(cudaMemcpy(cuda_stats, stats, (max_forks + 1) * sizeof(int), cudaMemcpyHostToDevice));
    dim3 grid(1, 1, 1); // Only 1 block for this kernel
    dim3 threadsPerBlock(9, 9, 1); // 9x9 threads per block, total 81 threads
    fillSudokuSafeAndFork<<<grid, threadsPerBlock>>>(cuda_memory, cuda_stats);
    GPUErrorAssertion(cudaDeviceSynchronize());
    GPUErrorAssertion(cudaMemcpy(stats, cuda_stats, (max_forks + 1) * sizeof(int), cudaMemcpyDeviceToHost));
    GPUErrorAssertion(cudaMemcpy(sudoku_memory, cuda_memory, 81 * max_forks, cudaMemcpyDeviceToHost));
    GPUErrorAssertion(cudaFree(cuda_memory));
    GPUErrorAssertion(cudaFree(cuda_stats));
    free(memory);
}

// Function: printSudoku
// Description: Function to print Sudoku grid.
// Parameters:
// - sudoku_memory: Pointer to the memory containing the Sudoku boards.
void printSudoku(char* sudoku_memory) {
    printf("Sudoku Solution:\n");
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            printf("%d ", sudoku_memory[i * 9 + j]);
        }
        printf("\n");
    }
}

int main() {
    // Example Sudoku board, 0 represents empty cells
    char sudoku_memory[81] = {
        5, 3, 0, 0, 7, 0, 0, 0, 0,
        6, 0, 0, 1, 9, 5, 0, 0, 0,
        0, 9, 8, 0, 0, 0, 0, 6, 0,
        8, 0, 0, 0, 6, 0, 0, 0, 3,
        4, 0, 0, 8, 0, 3, 0, 0, 1,
        7, 0, 0, 0, 2, 0, 0, 0, 6,
        0, 6, 0, 0, 0, 0, 2, 8, 0,
        0, 0, 0, 4, 1, 9, 0, 0, 5,
        0, 0, 0, 0, 8, 0, 0, 7, 9
    };
    int stats[9];
    int max_forks = 1; // Number of blocks (or Sudoku boards) to solve
    clock_t start, end;
    double cpu_time_used;
    start = clock();
    solveSudokuGPU(sudoku_memory, stats, max_forks);
    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
    printf("Sudoku solved using GPU in %f seconds\n", cpu_time_used);

    // Print Sudoku solution
    printSudoku(sudoku_memory);

    return 0;
}
